---
layout: post
title: Oracle中视图 序列 同义词 索引
date: 2019-10-12
comments: true
external-url:
categories: Oracle 
---

```
1.视图
    视图是一种数据库对象，是从一个或者多个数据表或视图中导出的虚表，视图所对应的数据并不真正地存储在视图中，而是存储在所引用的数据表中，视图的结构和数据是对数据表进行查询的结果。视图相当于一条sql语句的封装，每次访问时，都会执行sql语句
    
    使用视图的优点：
        简化数据操作：视图可以简化用户处理数据的方式。简化sql语句操作
        
    创建格式：
        CREATE [OR REPLACE] [FORCE] VIEW view_name     
        AS subquery   
        [WITH CHECK OPTION ]   
        [WITH READ ONLY] 
 
    OR REPLACE  ：若所创建的试图已经存在，ORACLE 自动重建该视图；
    FORCE        ：不管基表是否存在 ORACLE 都会自动创建该视图；
    subquery       ：一条完整的 SELECT 语句，可以在该语句中定义别名；
    WITH CHECK OPTION  ：插入或修改的数据行必须满足视图定义的约束；
    WITH READ ONLY  ：该视图上不能进行任何 DML 操作。
    
    基表：创建视图的原始表
    
    删除视图： DROP  VIEW view_name 
    
    复杂视图中的键保留表：基表中的主键在视图中依然可以作为主键，则此主键所在的基表就称为键保留表，修改视图中数据时，只能修改键保留表中的值
    原因：对视图的修改，实际上是对基表中的数据进行修改，如果不是键保留表中的字段，则无法定位，故不可修改
```

```
2.物化视图        //提高查询效率
    物化视图与普通的视图相比的区别是物化视图是建立的副本，它类似于一张物理表，需要占用存储空间。而对一个物化视图查询的执行效率与查询一个表是一样
的。
    创建格式：
    CREATE  MATERIALIZED VIEW view_name         
    [BUILD IMMEDIATE  | BUILD DEFERRED ]         //生成数据的时间
    REFRESH [FAST|COMPLETE|FORCE]                  //刷新的方式    
    [  ON  [COMMIT  |DEMAND  ]  |  START  WITH  (start_time)  NEXT     //刷新的时机
    (next_time)  
    ]  
    AS 
    subquery 
    
    BUILD IMMEDIATE  是在创建物化视图的时候就生成数据（默认）
    BUILD  DEFERRED   则在创建时不生成数据，以后根据需要再生成数据。
    refresh：
        fast:            采用增量刷新，只刷新自上次刷新以后进行的修改
        commplete:        对整个物化视图进行完全的刷新
        force:            刷新时会去判断是否可以进行快速刷新，如果可以则采用 FAST 方式，否则采用 COMPLETE（默认方式）
        
        on commit        指在基表发生 COMMIT 操作时自动刷新
        on demmand        手动刷新，需要运行以下语句才能提交：
                            begin 
                            DBMS_MVIEW.refresh('MV_ADDRESS','C'); 
                            end;
                        实际上是系统内置的存储过程
    当刷新设置为增量刷新fast时，
    1.需要创建物化视图日志：
    create materialized view log on t_address with rowid;
    2.在查询语句中，必须包含所有表的rowid
```

``` 
3.序列        
产生连续的值，常用于主键自动生长序列是 ORACLE 提供的用于产生一系列唯一数字的数据库对象;

    create sequence  序列名称           //创建序列
    select 序列名称.nextval from dual    //获取序列中下一个数
    select  序列名称.currval from dual    //获取序列当前数
    
    create sequence 序列名        
    [INCREMENT BY n]                //每次递增的值
    [START WITH n]                    //开始的值
    [{MAXVALUE n | NOMAXVALUE}]        //最大值
    [{MINVALUE n | NOMINVALUE}]        //最小值
    [{CYCLE | NOCYCLE}]                //是否循环
    [{CACHE n | NOCACHE}]            //分配并存入内存中的个数，缓存的个数cache:电脑高速缓冲存储器
    
注意：
开始值不能比最小值小
每次递增的值必须小于等于最大值减最小值
如果是循环，必须指定最大值，且必须满足：最大值>最小值+(每次递增的值*缓存的个数)
    
修改序列：
    ALTER SEQUENCE  序列名称  MAXVALUE 5000 CYCLE;        //start with开始值不能修改
删除序列：
    DROP SEQUENCE  序列名称;
```

```
4.同义词
    同义词实质上是指定方案对象的一个别名。
    create [public] SYNONYM synooym for object;     //加public表示公有，当其他用户登录后也可直接通过此别名访问对应对象
    drop synonym 要删除的同义词        //删除同义词
```

```

5.索引        //提高查询效率
    索引是用于加速数据存取的数据对象，提高查询效率
    索引是需要占据存储空间的，也可以理解为是一种特殊的数据。形式类似于一棵“树”，而树的节点存储的就是每条记录的物理地址，也就是我们提到的伪列（ROWID）

    create index 索引名称 on 表名(列名);    //创建普通索引
    create unique index 索引名称 on 表名(列名);    //当这一列不会有重复的值的时候，可以设置唯一索引，设置完唯一索引相当于设置了唯一约束
    create index 索引名称 on 表名(列名,列名.....);    //复合索引，当需要经常使用几个列进行查询的时候，可以为这几列设置复合索引。
                                                    使用这几列查询时，where后面条件的顺序，必须和设置索引的顺序一致，否则和普通查询一样。
    create index 索引名称 on 表名(列名) reverse;    //当某个字段的值为连续增长的值，如果构建标准索引，会形成歪脖子树。这样会增加查询的层数，性能会下降。
                                                    建立反向键索引，可以使索引的值变得不规则，从而使索引树能够均匀分布
    create bitmap index 索引名称 on 表名(列名);        //位图索引适合创建在低基数列上
```
参考：

>https://www.cnblogs.com/liuxuelin/p/10004137.html